# A0153658W
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.EventsCenter;
import seedu.task.commons.events.ui.JumpToListRequestEvent;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.model.task.*;

import java.time.LocalDateTime;

/**
 * Adds a task to our task book
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task list. " 
    + "\nParameters: TASK_NAME [END_DATETIME] [START_DATETIME END_DATETIME] " 
    + "\nExample: " + COMMAND_WORD + " Dave's Birthday Party 12-01-2016 14:00 12-02-2016 16:00";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task list";

    private final Task toAdd;

    /**
     * Constructor for adding an event task
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskName, LocalDateTime startDate, LocalDateTime endDate)
            throws IllegalValueException {
    	
        this.toAdd = new EventTask(
                new Name(taskName),
                new TaskDate(startDate),
                new TaskDate(endDate)
        );
    }
    
    /**
     * Constructor for adding a deadline task
     * 
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskName, LocalDateTime endDate)
            throws IllegalValueException {
        
        this.toAdd = new DeadlineTask(
                new Name(taskName),
                new TaskDate(endDate)
        );
    }
    
    /**
     * Constructor for adding a floating task
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskName)
            throws IllegalValueException {
        
        this.toAdd = new Task(
                new Name(taskName)
        );
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getFilteredTaskList().size() - 1));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Deletes a task identified using it's last displayed index from the task list.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";

    public final int targetIndex;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.deleteTask(taskToDelete, "delete");
        } catch (TaskNotFoundException tnfe) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(String.format(Messages.MESSAGE_TASK_NOT_FOUND, taskToDelete.toString()));
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.commons.util.CollectionUtil;
import seedu.task.model.task.DeadlineTask;
import seedu.task.model.task.EventTask;
import seedu.task.model.task.Name;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.TaskDate;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Edits a task identified using it's last displayed index from the task list.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) "
            + "[END_DATETIME] [START_DATETIME END_DATETIME] [NEW_NAME]\n" + "Example: " + COMMAND_WORD + " 1"
            + " 12-10-2016";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";
    public static final String MESSAGE_EDIT_TASK_FAIL = "This task already exists in the task list";

    private static final int EDIT_CASE_DEADLINE = 0;
    private static final int EDIT_CASE_EVENT = 1;
    private static final int EDIT_CASE_FLOATING = 2;

    public final int targetIndex;
    private Name newName;
    private TaskDate endDateTime;
    private TaskDate startDateTime;
    private int editCase;

    /**
     * Constructor for editing specified task into a floating task
     */
    public EditCommand(int targetIndex, Name name) {
        if (name == null) {
            throw new IllegalArgumentException();
        }
        this.targetIndex = targetIndex;
        this.newName = name;
        editCase = EDIT_CASE_FLOATING;
    }

    /**
     * Constructor for editing specified task into a deadline
     */
    public EditCommand(int targetIndex, TaskDate endDateTime) {
        assert !CollectionUtil.isAnyNull(endDateTime);
        this.targetIndex = targetIndex;
        this.endDateTime = endDateTime;
        editCase = EDIT_CASE_DEADLINE;
    }

    /**
     * Constructor for editing specified task into an event
     */
    public EditCommand(int targetIndex, TaskDate startDateTime, TaskDate endDateTime) {
        assert !CollectionUtil.isAnyNull(startDateTime, endDateTime);
        this.targetIndex = targetIndex;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        editCase = EDIT_CASE_EVENT;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        Task taskToEdit = (Task) lastShownList.get(targetIndex - 1);
        int taskIndex;
        Task resultTask = null;
        try {
            taskIndex = model.getIndex(taskToEdit);

            switch (editCase) {
            case EDIT_CASE_DEADLINE:
                resultTask = new DeadlineTask(taskToEdit.getName(), endDateTime);
                break;
            case EDIT_CASE_EVENT:
                resultTask = new EventTask(taskToEdit.getName(), startDateTime, endDateTime);
                break;
            case EDIT_CASE_FLOATING:
                resultTask = new Task(newName);
                break;
            default:
                assert false : "All cases should have been handled by EditParser.";
            }
            try {
                model.editTask(taskIndex, taskToEdit, resultTask);
            } catch (DuplicateTaskException e) {
                e.printStackTrace();
            }
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
            return new CommandResult(MESSAGE_EDIT_TASK_FAIL);
        }

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, resultTask));
    }
}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
package seedu.task.logic.commands;

import java.util.EmptyStackException;
import seedu.task.model.task.Status;

/*
 * Command to undo most recent task
 */
public class UndoCommand extends Command{
	public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undo the most recent task.";

    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo successful, reversed action: %s";
    public static final String MESSAGE_UNDO_STACK_END = "Nothing to undo.";


    public UndoCommand() {}
    
	@Override
	public CommandResult execute() {
		try{
			model.undo();
			model.updateFilteredListByStatus(Status.STATUS_PENDING);
		}
		catch(EmptyStackException e){
			return new CommandResult(MESSAGE_UNDO_STACK_END);
		}
		return new CommandResult(String.format(MESSAGE_UNDO_TASK_SUCCESS, model.getUndoInformation()));
	}
	    
}
```
###### /java/seedu/task/logic/commands/UserCommandLog.java
``` java
package seedu.task.logic.commands;

import java.util.ArrayList;

/*
 * Maintains a log for the commands that the user has typed. This is used
 * for the previous/forward command feature, where the user can type the up 
 * 
 */
public class UserCommandLog {
    private ArrayList<String> userCommandLog;
    private int currentCommandIndex;

    public UserCommandLog() {
        userCommandLog = new ArrayList<String>();
        currentCommandIndex = 0;
    }

    public void addCommandToUserLog(String userCommand) {
        userCommandLog.add(userCommand);
        currentCommandIndex = userCommandLog.size();
    }

    public String getPreviousCommand() {
        String previousCommand = "";
        if (currentCommandIndex - 1 >= 0) {
            currentCommandIndex -= 1;
            previousCommand = userCommandLog.get(currentCommandIndex);
        } else {
            previousCommand = userCommandLog.get(0);
        }
        return previousCommand;
    }

    public String getNextCommand() {
        String nextCommand = "";

        if (currentCommandIndex + 1 < userCommandLog.size()) {
            currentCommandIndex += 1;
            nextCommand = userCommandLog.get(currentCommandIndex);
        } else {
            nextCommand = "";
            currentCommandIndex = userCommandLog.size();
        }
        return nextCommand;
    }
}
```
###### /java/seedu/task/model/ModelManager.java
``` java
package seedu.task.model;

import javafx.collections.transformation.FilteredList;
import seedu.task.commons.core.ComponentManager;
import seedu.task.commons.core.Config;
import seedu.task.commons.core.LogsCenter;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.commons.events.model.TaskBookChangedEvent;
import seedu.task.commons.events.storage.StorageFilePathChangedEvent;
import seedu.task.commons.events.ui.DatePickedOnCalendarEvent;
import seedu.task.commons.events.ui.DisplayDirectoryChooserRequestEvent;
import seedu.task.commons.events.ui.DisplayDirectoryChooserRequestEvent.DirectoryChooserOperationCancelledException;
import seedu.task.commons.events.ui.TaskPanelDataChangedEvent;
import seedu.task.commons.util.ConfigUtil;
import seedu.task.commons.util.DateUtil;
import seedu.task.commons.util.StringUtil;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Status;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;
import seedu.task.model.task.UniqueTaskList.NoCompletedTasksFoundException;
import seedu.task.model.task.UniqueTaskList.TaskAlreadyCompletedException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

import java.io.IOException;
import java.time.LocalDate;
import java.util.Set;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

/**
 * Represents the in-memory model of the task book data.
 * All changes to any model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final TaskBook taskBook;
    private final FilteredList<Task> filteredTasks;

    /**
     * Initializes a ModelManager with the given TaskBook
     * TaskBook and its variables should not be null
     */
    public ModelManager(TaskBook src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;

        logger.fine("Initializing with task book: " + src + " and user prefs " + userPrefs);

        taskBook = new TaskBook(src);
        filteredTasks = new FilteredList<>(taskBook.getTasks());
    }

    public ModelManager() {
        this(new TaskBook(), new UserPrefs());
    }

    public ModelManager(ReadOnlyTaskBook initialData, UserPrefs userPrefs) {
        taskBook = new TaskBook(initialData);
        filteredTasks = new FilteredList<>(taskBook.getTasks());
    }

    @Override
    public void resetData(ReadOnlyTaskBook newData) {
        taskBook.resetData(newData);
        indicateTaskBookChanged();
    }

    @Override
    public ReadOnlyTaskBook getTaskBook() {
        return taskBook;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTaskBookChanged() {
        raise(new TaskBookChangedEvent(taskBook));
    }
```
###### /java/seedu/task/model/ModelManager.java
``` java
    @Override
    public synchronized void deleteTask(ReadOnlyTask target, String callingCommand) throws TaskNotFoundException {
        taskBook.removeTask(target, callingCommand);
        indicateTaskBookChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        taskBook.addTask(task);
        updateFilteredListByStatus(Status.STATUS_PENDING);
        indicateTaskBookChanged();
    }
	
    @Override
    public synchronized void addTask(int taskIndex, Task task) throws UniqueTaskList.DuplicateTaskException {
        taskBook.addTask(taskIndex, task);
        updateFilteredListByStatus(Status.STATUS_PENDING);
        indicateTaskBookChanged();
    }
    
    @Override
    public synchronized void editTask(int taskIndex, Task taskToEdit, Task resultTask) throws UniqueTaskList.DuplicateTaskException {
        taskBook.editTask(taskIndex, taskToEdit, resultTask);
        indicateTaskBookChanged();
    }
    
```
###### /java/seedu/task/model/ModelManager.java
``` java
	@Override
    public void clearAllTasks() {
	    taskBook.clearAllTasks();
        indicateTaskBookChanged();
    }
	
    @Override
    public void undo(){
        taskBook.undoTask();
        indicateTaskBookChanged();
        indicateTaskListPanelDataChanged();
    }
    
    public String getUndoInformation(){
        return taskBook.getUndoInformation();
    }

	@Override
	public int getIndex(ReadOnlyTask target) throws TaskNotFoundException {
		return taskBook.getIndex(target);
	}
	
    //=========== Filtered Task List Accessors ===============================================================
```
###### /java/seedu/task/model/task/DeadlineTask.java
``` java
package seedu.task.model.task;

import java.util.Objects;

/*
 * Represents a task with a deadline
 */
public class DeadlineTask extends Task{
	private TaskDate endDate;
	
	/*
	 * Constructor for a task with a deadline
	 */
	public DeadlineTask(Name name, TaskDate endDate){
		super(name);
		this.endDate = endDate;
	}
	
	public DeadlineTask(Name name, TaskDate taskEndDate, Status taskStatus) {
	    super(name, taskStatus);
	    endDate = taskEndDate;
    }

    public TaskDate getEndDate(){
		return endDate;
	}
	
	/*
	 * Replaces this task's end date with the new end date
	 */
	public void setEndDate(TaskDate newEndDate){
		this.endDate = newEndDate;
	}
	
	@Override
    public String toString() {
	    StringBuilder sb = new StringBuilder();
	    sb.append(this.getName().toString());
	    sb.append(" due ");
	    sb.append(endDate.toString());
        return sb.toString();
    }
	
	@Override
	public TaskDate getEnd() {
		return endDate;
	}
	
	@Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DeadlineTask // instanceof handles nulls
                && this.hashCode() == other.hashCode());
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(getName(), "endDate:" + endDate.toString());
    }
}
```
###### /java/seedu/task/model/task/EventTask.java
``` java
package seedu.task.model.task;

import java.util.Objects;

/*
 * Represents a task as an event, i.e. it will have a start and end date/time
 */
public class EventTask extends Task {
    private TaskDate startDate, endDate;

    public EventTask(Name name, TaskDate startDate, TaskDate endDate) {
        super(name);
        this.startDate = startDate;
        this.endDate = endDate;
    }

    public EventTask(Name name, TaskDate taskStartDate, TaskDate taskEndDate, Status taskStatus) {
        super(name, taskStatus);
        this.startDate = taskStartDate;
        this.endDate = taskEndDate;
    }

    public TaskDate getStartDate() {
        return startDate;
    }

    /*
     * Replaces this task's start date with the new start date
     */
    public void setStartDate(TaskDate startDate) {
        this.startDate = startDate;
    }

    public TaskDate getEndDate() {
        return endDate;
    }

    /*
     * Replaces this task's end date with the new end date
     */
    public void setEndDate(TaskDate newEndDate) {
        this.endDate = newEndDate;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(this.getName().toString());
        sb.append(" start from ");
        sb.append(startDate.toString());
        sb.append(" to ");
        sb.append(endDate.toString());
        return sb.toString();
    }

    @Override
    public TaskDate getStart() {
        return startDate;
    }

    @Override
    public TaskDate getEnd() {
        return endDate;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof EventTask // instanceof handles nulls
                        && this.hashCode() == other.hashCode());
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(getName(), "startDate:" + startDate.toString(), "endDate:" + endDate.toString());
    }
}
```
###### /java/seedu/task/model/task/ReadOnlyTask.java
``` java
package seedu.task.model.task;

import seedu.task.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the TaskList.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();
    TaskDate getStart();
    TaskDate getEnd();
    Status getStatus();

    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()));
    }

    /**
     * Formats the task as text
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        return builder.toString();
    }

    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }

}
```
###### /java/seedu/task/model/task/Task.java
``` java
package seedu.task.model.task;

import seedu.task.commons.util.CollectionUtil;
import seedu.task.model.tag.UniqueTagList;

import java.util.Objects;

/**
 * Represents a parent class, Task, in the Task List.
 */
public class Task implements ReadOnlyTask {
    private Name name;
    private UniqueTagList tags;
    private Status status;

    /**
     * A task must be present and not null.
     */
    public Task(Name name) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        status = new Status(Status.STATUS_PENDING);
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName());
        status = new Status(Status.STATUS_PENDING);
    }

    public Task(Name name, Status status) {
        assert !CollectionUtil.isAnyNull(name, status);
        this.name = name;
        this.status = status;
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }
    
    /*
     * Replaces this task name with new task name
     */
    public void setName(Name newName){
    	this.name = newName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

	@Override
	public Name getName() {
		return name;
	}

	@Override
	public UniqueTagList getTags() {
		return tags;
	}

	@Override
	public TaskDate getStart() {
		return null;
	}

	@Override
	public TaskDate getEnd() {
		return null;
	}

    @Override
    public Status getStatus() {
        return status;
    }
    
    /**
     * Returns true if task is already completed.
     */
    public boolean isComplete() {
        return status.isComplete();
    }
    
    /**
     * Set the task as completed.
     */
    public void setComplete() {
        status.setComplete();
    }
    
    /**
     * Set the task as pending.
     */
    public void setPending(){
    	status.setPending();
    }
}
```
###### /java/seedu/task/model/task/TaskDate.java
``` java
package seedu.task.model.task;

import java.time.LocalDateTime;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.commons.util.DateUtil;

/**
 * Represents a Task date in the Task List.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class TaskDate implements Comparable<TaskDate> {

    public static final String MESSAGE_DATE_CONSTRAINTS = "Task date should be specified in following format"
    		+ " 06-10-2016 14:00";
    public static final String DATE_VALIDATION_REGEX = "\\d{2}-\\d{2}-\\d{4}\\s\\d{2}:\\d{2}";

    public final LocalDateTime taskDate;

    /**
     * Validates given Date.
     */
    public TaskDate(LocalDateTime taskDate) {
        assert taskDate != null;
        this.taskDate = taskDate;
    }
    
    /**
     * Validates given Date.
     */
    public TaskDate(String strDateTime) throws IllegalValueException {
        strDateTime = strDateTime.trim();
        if (!isValidDate(strDateTime)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.taskDate = DateUtil.parseStringToLocalDateTime(strDateTime);
    }
    
    /**
     * Returns true if a given string is a valid task date.
     */
    public static boolean isValidDate(String test) {
        return test.matches(DATE_VALIDATION_REGEX);
    }
    
    public LocalDateTime getTaskDate() {
        return taskDate;
    }
    
    @Override
    public String toString() {
        return DateUtil.formatLocalDateTimeToString(taskDate);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && this.taskDate.equals(((TaskDate) other).taskDate)); // state check
    }

    @Override
    public int hashCode() {
        return taskDate.hashCode();
    }

    @Override
    public int compareTo(TaskDate td1) {
        if (this.taskDate.isAfter(td1.taskDate)) {
            return 1;
        } else if (this.taskDate.isEqual(td1.taskDate)) {
            return 0;
        } else {
            return -1;
        }
    }

}

```
###### /java/seedu/task/model/TaskBook.java
``` java
package seedu.task.model;

import javafx.collections.ObservableList;
import seedu.task.commons.core.Messages;
import seedu.task.model.tag.Tag;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.tag.UniqueTagList.DuplicateTagException;
import seedu.task.model.task.DeadlineTask;
import seedu.task.model.task.EventTask;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.task.model.task.UniqueTaskList.TaskAlreadyCompletedException;
import seedu.task.model.task.UniqueTaskList.NoCompletedTasksFoundException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Wraps all data at the task-book level Duplicates are not allowed (by .equals
 * comparison)
 */
public class TaskBook implements ReadOnlyTaskBook {

    private UniqueTaskList tasks;
    private UniqueTagList tags;

    private UndoTaskStack undoTaskStack;
    private static final String UNDO_ADD_COMMAND = "add";
    private static final String UNDO_DELETE_COMMAND = "delete";
    private static final String UNDO_EDIT_COMMAND = "edit";
    private static final String UNDO_COMPLETE_COMMAND = "complete";
    private static final String UNDO_CLEAR_COMMAND = "clear";
    private static final String UNDO_CLEAR_ALL_COMMAND = "clear all";

    {
        tasks = new UniqueTaskList();
        tags = new UniqueTagList();
        undoTaskStack = new UndoTaskStack();
    }

    public TaskBook() {
    }

```
###### /java/seedu/task/model/TaskBook.java
``` java
    //// task-level operations

    /**
     * Adds a task to the task book. Also checks the new task's tags and updates
     * {@link #tags} with any new tags found, and updates the Tag objects in the
     * task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException
     *             if an equivalent task already exists.
     */
    public void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        tasks.add(task);
        undoTaskStack.pushAddToUndoStack(UNDO_ADD_COMMAND, task, -1);
    }

    /**
     * Adds a task to the task list at a given index.
     *
     * @throws UniqueTaskList.DuplicateTaskException
     *             if an equivalent task already exists.
     */
    public void addTask(int taskIndex, Task task) throws UniqueTaskList.DuplicateTaskException {
        tasks.add(taskIndex, task);
    }

    /**
     * Ensures that every tag in this task: - exists in the master list
     * {@link #tags} - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : tags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        task.setTags(new UniqueTagList(commonTagReferences));
    }

    public boolean removeTask(ReadOnlyTask key, String callingCommand) throws UniqueTaskList.TaskNotFoundException {
        int targetIndex = tasks.getIndex(key);

        if (tasks.remove(key)) {
            undoTaskStack.pushDeleteToUndoStack(key, callingCommand, targetIndex);
            return true;
        } else {
            throw new TaskNotFoundException();
        }
    }

    /**
     * Edits a task to the task at a given index.
     *
     * @throws UniqueTaskList.DuplicateTaskException
     *             if an equivalent task already exists.
     */
    public void editTask(int taskIndex, Task taskToEdit, Task resultTask) throws UniqueTaskList.DuplicateTaskException {
        undoTaskStack.pushEditToUndoStack(UNDO_EDIT_COMMAND, taskToEdit, taskIndex);

        try {
            tasks.edit(taskIndex, resultTask);
        } catch (TaskNotFoundException e) {
            e.printStackTrace();
        }
    }

```
###### /java/seedu/task/model/TaskBook.java
``` java
    public int getIndex(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        return tasks.getIndex(key);
    }

    /**
     * Clears completed tasks from the task book
     * 
     * @throws NoCompletedTasksFoundException
     *             if no completed tasks were found
     */
    public void clearCompletedTasks() throws NoCompletedTasksFoundException {
        UniqueTaskList copyTasks = copyUniqueTaskList(tasks);
        List<Task> clearedTasks = new ArrayList<Task>();
        List<Integer> clearedTasksIndices = new ArrayList<Integer>();

        prepareCompletedTasksForUndo(copyTasks, clearedTasks, clearedTasksIndices);

        // actually remove the completed tasks
        for (Task readTask : copyTasks) {
            if (readTask.isComplete()) {
                try {
                    tasks.remove(readTask);
                } catch (TaskNotFoundException e) {
                    assert false : "The target task cannot be missing";
                }
            }
        }
        if (copyTasks.size() == tasks.size()) {
            throw new NoCompletedTasksFoundException();
        }

        undoTaskStack.pushClearCompletedToUndoStack(clearedTasks, clearedTasksIndices, UNDO_CLEAR_COMMAND);
    }

    /*
     * Helper method to compile set of tasks and indices for clearing all
     * completed tasks to prepare for undo stack
     */
    private void prepareCompletedTasksForUndo(UniqueTaskList copyTasks, List<Task> clearedTasks,
            List<Integer> clearedTasksIndices) {
        for (Task readTask : copyTasks) {
            if (readTask.isComplete()) {
                try {
                    clearedTasksIndices.add(tasks.getIndex(readTask));

                    Class<? extends ReadOnlyTask> clearedTask = readTask.getClass();

                    if (clearedTask.equals(DeadlineTask.class)) {
                        DeadlineTask cleared = new DeadlineTask(readTask.getName(), readTask.getEnd());
                        clearedTasks.add(cleared);
                    } else if (clearedTask.equals(EventTask.class)) {
                        EventTask cleared = new EventTask(readTask.getName(), readTask.getStart(), readTask.getEnd());
                        clearedTasks.add(cleared);
                    } else {
                        // cleared task must be a floating task
                        Task cleared = new Task(readTask.getName());
                        clearedTasks.add(cleared);
                    }
                } catch (TaskNotFoundException e) {
                    System.out.println((String.format(Messages.MESSAGE_TASK_NOT_FOUND, readTask.toString())));
                    return;
                }
            }
        }
    }

    /**
     * Clears all tasks from the task book
     */
    public void clearAllTasks() {
        UniqueTaskList copyTasks = copyUniqueTaskList(tasks);
        List<Task> clearedTasks = new ArrayList<Task>();
        List<Integer> clearedTasksIndices = new ArrayList<Integer>();
        List<String> clearedStatus = new ArrayList<String>();

        prepareClearedTasksForUndo(copyTasks, clearedTasks, clearedTasksIndices, clearedStatus);

        // actually remove the completed tasks
        for (Task readTask : copyTasks) {
            try {
                tasks.remove(readTask);
            } catch (TaskNotFoundException e) {
                System.out.println((String.format(Messages.MESSAGE_TASK_NOT_FOUND, readTask.toString())));
                return;
            }
        }

        undoTaskStack.pushClearAllToUndoStack(clearedTasks, clearedTasksIndices, clearedStatus, UNDO_CLEAR_ALL_COMMAND);
    }

    /*
     * Helper method to compile set of tasks and indices for clearing all tasks
     * to prepare for undo stack
     */
    private void prepareClearedTasksForUndo(UniqueTaskList copyTasks, List<Task> clearedTasks,
            List<Integer> clearedTasksIndices, List<String> clearedStatus) {
        // compile set of tasks and indices being cleared to prepare for undo
        // stack
        for (Task readTask : copyTasks) {
            try {
                clearedTasksIndices.add(tasks.getIndex(readTask));
                clearedStatus.add(readTask.getStatus().toString());

                Class<? extends ReadOnlyTask> clearedTask = readTask.getClass();

                if (clearedTask.equals(DeadlineTask.class)) {
                    DeadlineTask cleared = new DeadlineTask(readTask.getName(), readTask.getEnd());
                    clearedTasks.add(cleared);
                } else if (clearedTask.equals(EventTask.class)) {
                    EventTask cleared = new EventTask(readTask.getName(), readTask.getStart(), readTask.getEnd());
                    clearedTasks.add(cleared);
                } else {
                    // cleared task must be a floating task
                    Task cleared = new Task(readTask.getName());
                    clearedTasks.add(cleared);
                }

            } catch (TaskNotFoundException e) {
                System.out.println((String.format(Messages.MESSAGE_TASK_NOT_FOUND, readTask.toString())));
            }
        }
    }

    public void undoTask() {
        undoTaskStack.undo(tasks);
    }

    public String getUndoInformation() {
        return undoTaskStack.getUndoInformation();
    }

```
###### /java/seedu/task/model/UndoTaskStack.java
``` java
package seedu.task.model;

import java.util.EmptyStackException;
import java.util.List;
import java.util.Stack;

import seedu.task.commons.core.Messages;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.CommandResult;
import seedu.task.model.task.DeadlineTask;
import seedu.task.model.task.EventTask;
import seedu.task.model.task.Name;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

public class UndoTaskStack {
    private Stack<String> previousActionType = new Stack<>();
    private Stack<Task> previousTask = new Stack<>();
    private Stack<Integer> previousActionIndex = new Stack<>();

    private Stack<List<Task>> previousClearedTasks = new Stack<>();
    private Stack<List<Integer>> previousClearedIndices = new Stack<>();
    private Stack<List<String>> previousClearedStatus = new Stack<>();

    private String previousActionUndoString;
    
    private static final String MESSAGE_NOTHING_TO_UNDO = "Nothing to undo.";

    public UndoTaskStack() {
    }

    /**
     * Pushes the add command to the undo stack.
     * 
     * @params callingCommand, addedTask
     * 
     *         callingCommand will be "add" or "edit add" addedTask is the task
     *         added targetIndex holds the index specified by the user that they
     *         added
     **/
    public void pushAddToUndoStack(String callingCommand, Task addedTask, int targetIndex) {
        previousActionType.push(callingCommand);
        previousActionIndex.push(-1);
        previousTask.push(addedTask);
    }

    /**
     * Pushes the delete command to the undo stack.
     * 
     * @params key, callingCommand, targetIndex
     * 
     *         key is the task that the user deleted or edited callingCommand
     *         will either be "delete" or "edit" targetIndex holds the index
     *         specified by the user that they deleted or edited
     **/
    public void pushDeleteToUndoStack(ReadOnlyTask key, String callingCommand, int targetIndex) {
        previousActionType.push(callingCommand);
        previousActionIndex.push(targetIndex);

        Class<? extends ReadOnlyTask> deletedTask = key.getClass();

        if (deletedTask.equals(DeadlineTask.class)) {
            DeadlineTask deleted = new DeadlineTask(key.getName(), key.getEnd());
            previousTask.push(deleted);
        } else if (deletedTask.equals(EventTask.class)) {
            EventTask deleted = new EventTask(key.getName(), key.getStart(), key.getEnd());
            previousTask.push(deleted);
        } else {
            // deleted task must be a floating task
            Task deleted = new Task(key.getName());
            previousTask.push(deleted);
        }
    }

    /**
     * Pushes the edit command to the undo stack.
     * 
     * @params callingCommand, taskToEdit
     * 
     *         callingCommand will be "edit" taskToEdit is the task before it is
     *         edited targetIndex holds the index of the task about to be edited
     **/
    public void pushEditToUndoStack(String callingCommand, Task taskToEdit, int targetIndex) {
        previousActionType.push(callingCommand);
        previousActionIndex.push(targetIndex);
        previousTask.push(taskToEdit);
    }

    /**
     * Pushes the delete command to the undo stack.
     * 
     * @params taskToComplete, callingCommand, targetIndex
     * 
     *         taskToComplete is the task marked for completion callingCommand
     *         will be "complete" targetIndex holds the index specified by the
     *         user to complete
     **/
    public void pushCompleteToUndoStack(Task taskToComplete, String callingCommand, int targetIndex) {
        previousActionType.push(callingCommand);
        previousActionIndex.push(targetIndex);
        previousTask.push(taskToComplete);
    }

    /**
     * Pushes the clear command to the undo stack.
     * 
     * @params clearedTasks, clearedTasksIndices, callingCommand
     * 
     *         clearedTasks is the set of tasks that were cleared
     *         clearedTasksIndices is the set of indices corresponding to the
     *         tasks cleared callingCommand is the command passed in (it'll
     *         always be "clear")
     * 
     *         actionIndex will be -1; there is no index specified when clearing
     *         a set of tasks, just pushing to keep the stacks balanced
     **/
    public void pushClearCompletedToUndoStack(List<Task> clearedTasks, List<Integer> clearedTaskIndices, String callingCommand) {
        previousActionType.push(callingCommand);
        previousActionIndex.push(-1);

        previousClearedTasks.push(clearedTasks);
        previousClearedIndices.push(clearedTaskIndices);
        try {
            previousTask.push(new Task(new Name("filler")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }

    /**
     * Pushes the clear all command to the undo stack.
     * 
     * @params clearedTasks, clearedTasksIndices, callingCommand
     * 
     *         clearedTasks is the set of tasks that were cleared
     *         clearedTasksIndices is the set of indices corresponding to each
     *         tasks cleared clearedStatus is the set of statuses for each task
     *         cleared callingCommand is the command passed in (it'll always be
     *         "clear")
     * 
     *         actionIndex will be -1; there is no index specified when clearing
     *         a set of tasks, just pushing to keep the stacks balanced
     **/
    public void pushClearAllToUndoStack(List<Task> clearedTasks, List<Integer> clearedTaskIndices,
            List<String> clearedStatus, String callingCommand) {
        previousActionType.push(callingCommand);
        previousActionIndex.push(-1);

        previousClearedTasks.push(clearedTasks);
        previousClearedIndices.push(clearedTaskIndices);
        previousClearedStatus.push(clearedStatus);
        try {
            previousTask.push(new Task(new Name("filler")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }

    /**
     * Undo the previous action by popping off the stack
     **/
    public CommandResult undo(UniqueTaskList tasks) {
        if (!previousTask.isEmpty()) {
            Task userTask = previousTask.pop();
            String userAction = previousActionType.pop();
            int taskIndex = previousActionIndex.pop();

            switch (userAction) {
            // previous action was an add; delete the added task
            case "add":
                try {
                    tasks.remove(userTask);
                    previousActionUndoString = userAction + " " + userTask.toString();
                } catch (TaskNotFoundException e) {
                    return new CommandResult(String.format(Messages.MESSAGE_TASK_NOT_FOUND, userTask.toString()));
                }
                break;
            // previous action was a delete; add back the deleted task
            case "delete":
                try {
                    tasks.add(taskIndex, userTask);
                    previousActionUndoString = userAction + " " + (taskIndex + 1);
                } catch (DuplicateTaskException e) {
                    return new CommandResult(String.format(Messages.MESSAGE_DUPLICATE_TASK_FOUND, userTask.toString()));
                }
                break;
            // previous action was an edit; set back the old task
            case "edit":
                try {
                    tasks.edit(taskIndex, userTask);
                    previousActionUndoString = "edit" + " " + (taskIndex + 1) + " " + userTask.toString();
                } catch (TaskNotFoundException e) {
                    return new CommandResult(String.format(Messages.MESSAGE_TASK_NOT_FOUND, userTask.toString()));
                }
                break;
            // previous action was a complete; set the task back to pending
            case "complete":
                previousActionUndoString = userAction + " " + (taskIndex + 1);
                userTask = tasks.getTaskFromIndex(taskIndex);
                userTask.setPending();
                break;
            // previous action was a clear for completed tasks; add back the
            // tasks that were completed
            case "clear":
                previousActionUndoString = userAction;
                List<Task> lastCleared = previousClearedTasks.pop();
                List<Integer> lastClearedIndices = previousClearedIndices.pop();

                for (int i = 0; i < lastCleared.size(); i++) {
                    int indexToUnclear = lastClearedIndices.get(i);
                    Task taskToUnclear = lastCleared.get(i);
                    taskToUnclear.setComplete();
                    try {
                        tasks.add(indexToUnclear, taskToUnclear);
                    } catch (DuplicateTaskException e) {
                        return new CommandResult(String.format(Messages.MESSAGE_DUPLICATE_TASK_FOUND, userTask.toString()));
                    }
                }
                break;
            // previous action was a clear all regardless of status; add back
            // the tasks that were cleared
            case "clear all":
                previousActionUndoString = userAction;
                List<Task> lastClearedAll = previousClearedTasks.pop();
                List<Integer> lastClearedAllIndices = previousClearedIndices.pop();
                List<String> lastClearedStatuses = previousClearedStatus.pop();

                for (int i = 0; i < lastClearedAll.size(); i++) {
                    int indexToUnclear = lastClearedAllIndices.get(i);
                    Task taskToUnclear = lastClearedAll.get(i);
                    String taskStatus = lastClearedStatuses.get(i);
                    if (taskStatus.equals("Complete")) {
                        taskToUnclear.setComplete();
                    } else {
                        taskToUnclear.setPending();
                    }

                    try {
                        tasks.add(indexToUnclear, taskToUnclear);
                    } catch (DuplicateTaskException e) {
                        return new CommandResult(String.format(Messages.MESSAGE_DUPLICATE_TASK_FOUND, userTask.toString()));
                    }
                }
                break;
            default:
                System.out.println("Error occurred in undo stack");
            }
        } else {
            throw new EmptyStackException();
        }
        return new CommandResult(MESSAGE_NOTHING_TO_UNDO);
    }

    /*
     * Returns undo information back to UI i.e.
     * "Undo successful, reversed action: delete 1"
     */
    public String getUndoInformation() {
        return previousActionUndoString;
    }
}
```
###### /java/seedu/task/ui/CommandBox.java
``` java
    /**
     * Sets up key listeners for both the Up arrow and Down arrow
     */
    public void setArrowKeyListener() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent ke) {
                if (ke.getCode().equals(KeyCode.UP)) {
                    // get previous command
                    String previousCommand = userCommandLog.getPreviousCommand();
                    commandTextField.setText(previousCommand);

                    // move cursor caret to the end of the line
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            commandTextField.positionCaret(previousCommand.length());
                        }
                    });
                } else if (ke.getCode().equals(KeyCode.DOWN)) {
                    // get the next command
                    String nextCommand = userCommandLog.getNextCommand();
                    commandTextField.setText(nextCommand);

                    // move cursor caret to the end of the line
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            commandTextField.positionCaret(nextCommand.length());
                        }
                    });
                }
            }
        });
    }

}
```
